#!/usr/bin/env ruby

require 'yaml'
require 'toml-rb'
require 'rest-client'
require 'optparse'
require 'apipie-bindings'
require 'logger'
require 'parallel'
require 'k8s-client'
require 'diffy'

# @summary
#   Mixin for CLI options structs
module CLIOptionsMixin
  # @summary
  #   Mixin for loading CLI options from the environment
  module ClassOptions
    # Load struct options from the environment.
    #
    # @param env [Hash] A map of environment variables.
    def from_env(env)
      new.tap do |o|
        o.members.each do |member|
          o[member] = env[member.to_s.upcase]
        end
      end
    end
  end

  def self.included(klass)
    klass.extend(ClassOptions)
  end

  # @attribute [r] debug
  #   @return [Boolean]
  attr_accessor :debug

  def validate!
    errors = []

    members.each do |member|
      if self[member].nil?
        cli_opt = "--#{member.to_s.tr('_', '-')}"
        env_opt = member.to_s.upcase
        errors << "#{member}, CLI option #{cli_opt} or environment variable #{env_opt}"
      end
    end

    errors
  end
end

K8sOptions = Struct.new(
  :k8s_credentials,
  :k8s_namespace,
  :k8s_configmap,
  :k8s_configmap_key,
  :k8s_deployment,
  :k8s_volume
) do
  include CLIOptionsMixin

  def to_api
    if @debug
      K8s::Logging.debug!
      K8s::Transport.verbose!
    end

    case self[:k8s_credentials].to_sym
    when :cluster
      K8s::Client.in_cluster_config
    when :config
      K8s::Client.config(K8s::Config.load_file('~/.kube/config'))
    else
      raise "Unknown k8s credentials type #{self[:k8s_credentials]}"
    end
  end
end

ForemanOptions = Struct.new(
  :foreman_username,
  :foreman_password,
  :foreman_url,
  :ssl_ca_file
) do
  include CLIOptionsMixin

  def to_api
    logger = Logger.new(STDERR)
    logger.level = Logger::ERROR
    logger.level = Logger::DEBUG if @debug

    ApipieBindings::API.new({ uri: self[:foreman_url],
                              username: self[:foreman_username],
                              password: self[:foreman_password],
                              api_version: 2,
                              logger: logger },
                            ssl_ca_file: self[:ssl_ca_file])
  end
end

Options = Struct.new(:foreman, :k8s) do
  def self.from_env(env)
    new(ForemanOptions.from_env(env), K8sOptions.from_env(env))
  end

  def validate!
    members.flat_map { |member| self[member].validate! }
  end

  def debug
    members.map { |member| self[member].debug }.all?
  end

  def debug=(value)
    members.map { |member| self[member].debug = value }
  end
end

# @summary
#   The configmap holding the telegraf config file
class TelegrafConfigMap
  # @attribute [r] ns
  #   @return [String] The Kubernetes namespace
  attr_reader :ns

  # @attribute [r] name
  #   @return [String] The Telegraf configmap name
  attr_reader :name

  # @attribute[r] key
  #   @return [String] The target configmap key
  attr_reader :key

  def initialize(api, ns, name, key)
    @api = api
    @ns = ns
    @name = name
    @key = key

    @_current = nil
  end

  # @return [Boolean] true if the sync was performed, false otherwise
  def sync(desired)
    if insync?(desired)
      false
    else
      sync!(desired)
      true
    end
  end

  # @return [void]
  def sync!(desired)
    @api
      .api('v1')
      .resource('configmaps', namespace: @ns)
      .merge_patch(@name, data: { @key => desired })

    # Refresh the current state
    fetch!
  end

  # Is the current configmap content in sync with the desired content?
  #
  # @param desired [String] The desired content for the given ns/configmap/key tuple
  def insync?(desired)
    current == desired
  end

  # Generate a diff between the curre
  def diff(desired)
    Diffy::Diff.new(current, desired, context: 5).to_s(:color)
  end

  # Return or fetch the current configmap content
  # @return [String] The current configmap content
  def current
    @_current || fetch!
  end

  # Fetch and set the current configmap content
  # @return [String] The current configmap content
  def fetch!
    cm = @api.api('v1').resource('configmaps', namespace: @ns).get(@name)
    @_current = cm.data[@key]
  end
end

# @summary
#   A Telegraf deployment and volume definition matching the telegraf configmap
#
# Configmaps cannot have recursive directory entries; in order to utilize
# the `/etc/telegraf/telegraf.d/` directory we need to tweak the deployment volume
# definition to mount additional files at subpaths.
#
# @note
#   When a ConfigMap uses explicit paths for files (such as those under `telegraf.d`),
#   those paths are created as symlinks. Telegraf ignores symlinks by default; as a
#   workaround run Telegraf with `telegraf --config-directory /etc/telegraf/telegraf.d/`
#   with the trailing slash.
class DeploymentVolumeItem
  # @attribute [r] ns
  #   @return [String] The Kubernetes namespace
  attr_reader :ns

  # @attribute [r] deployment
  #   @return [String] The Telegraf deployment
  attr_reader :deployment

  # @attribute [r] volume
  #   @return [String] The Telegraf volume name
  attr_reader :volume

  # @attribute [r] configmap
  #   @return [String] The Telegraf configmap to mount
  attr_reader :configmap

  # @attribute [r] key
  #   @return [String] The Telegraf configmap key
  attr_reader :key

  # rubocop:disable Metrics/ParameterLists
  def initialize(api, ns, deployment, volume, configmap, key)
    @api = api
    @ns = ns
    @deployment = deployment
    @volume = volume
    @configmap = configmap
    @key = key

    @_current = nil
  end
  # rubocop:enable Metrics/ParameterLists

  # @return [Boolean] true if the sync was performed, false otherwise
  def sync(desired)
    if insync?(desired)
      false
    else
      sync!(desired)
      true
    end
  end

  # Synchronize the given configmap volume mount item.
  # # Examples
  #
  # ```
  # ns = 'telegraf'
  #
  # # deployment/telegraf-ping
  # deploy = 'telegraf-ping'
  # # default volume name from telegraf chart
  # volume = 'config'
  #
  # # configmap/telegraf-ping
  # configmap = 'telegraf-ping'
  # configmap_key = 'ping.conf'
  #
  # items = DeploymentVolumeItem.new(api, ns, deploy, volume, configmap, configmap_key)
  #
  # items.sync(
  #   key: 'dns.conf',
  #   path: 'telegraf.d/dns.conf'
  # )
  # ```
  #
  # @return [void]
  def sync!(desired)
    # Ensure that the telegraf.conf item is always mounted
    items = [
      {
        key: 'telegraf.conf',
        path: 'telegraf.conf'
      },
      desired
    ].sort_by { |item| item[:path] }

    cm_volume = {
      name: @volume,
      configMap: {
        name: @configmap,
        defaultMode: 420,
        items: items
      }
    }

    patch = {
      spec: {
        template: {
          spec: {
            volumes: [cm_volume]
          }
        }
      }
    }

    @api
      .api('apps/v1')
      .resource('deployments', namespace: @ns)
      .merge_patch(@deployment, patch)

    # Refresh the current state
    fetch!
  end

  # Is the current deployment content in sync with the desired content?
  #
  # @param desired [String] The desired content for the given ns/deployment/key tuple
  def insync?(desired)
    current == desired
  end

  # Generate a diff between the current and desired telegraf deployment volume.
  def diff(desired)
    Diffy::Diff.new(current, desired, context: 5).to_s(:color)
  end

  # Return or fetch the current configmap content
  # @return [String] The current configmap content
  def current
    @_current || fetch!
  end

  # Fetch and set the current configmap content
  # @return [String] The current configmap content
  def fetch!
    cm = @api.api('apps/v1').resource('deployments', namespace: @ns).get(@deployment)
    volume = cm.spec.template.spec.volumes.map(&:to_h).find { |h| h[:name] == @volume }
    items = volume.dig(:configMap, :items) || []
    @_current = items.find { |item| item[:key] == @key }
  end
end

# @summary
#   A Foreman host entry, with associated interfaces
class ForemanHost
  # @attribute [r] host
  #   @return [Hash] The Foreman host entry
  attr_reader :host

  # @attribute [r] interfaces
  #   @return The Foreman host interfaces
  attr_reader :interfaces

  # Fetch all host definitions and interfaces
  #
  # @param api Apipie::Api
  def self.all(api)
    entries = api.resource(:hosts).call(:index)["results"]

    Parallel.map(entries, in_processes: 16) do |host|
      ForemanHost.query_interfaces(host, api)
    end
  end

  # Given a Foreman host entry, fetch the associated interfaces and generate
  # a new `ForemanHost`.
  #
  # @param host Hash
  # @param api Apipie::Api
  def self.query_interfaces(host, api)
    interfaces = api
                 .resource(:interfaces)
                 .call(:index, host_id: host['id'])
                 .fetch('results')

    new(host, interfaces)
  end

  def initialize(host, interfaces)
    @host = host
    @interfaces = interfaces
  end

  # @return [String]
  def name
    @host['name']
  end

  def managed_interfaces
    interfaces.select { |entry| entry["managed"] }
  end

  # @return Array[Hash] All managed interfaces with IP and MAC addresses
  def configured_interfaces
    managed_interfaces.select { |entry| entry["ip"] && entry["mac"] }
  end

  # @return [Array[String]] All A records assigned to interfaces of this host
  def fqdns
    configured_interfaces.map { |entry| entry["fqdn"] }.compact.sort
  end
end

def ping_inputs_for_hosts(hosts)
  targets = hosts.map do |host|
    {
      count: 5,
      deadline: 5,
      interval: 1,
      urls: host.fqdns,
      #tags: {
      #  subject: host.name
      #}
    }
  end

  TomlRB.dump(inputs: { ping: targets })
end

def gen_config(opts)
  all_hosts = ForemanHost.all(opts.foreman.to_api)
  ping_inputs_for_hosts(all_hosts)
end

def update_configmap(opts, desired_conf)
  client = opts.k8s.to_api
  tcm = TelegrafConfigMap.new(client,
                              opts.k8s[:k8s_namespace],
                              opts.k8s[:k8s_configmap],
                              opts.k8s[:k8s_configmap_key])

  synced = tcm.insync?(desired_conf)
  puts "k8s configmap insync: #{synced}"
  puts tcm.diff(desired_conf) if !synced

  if tcm.sync(desired_conf)
    puts "ns:#{opts.k8s[:k8s_namespace]}" \
      ":configmap:#{opts.k8s[:k8s_configmap]}" \
      ":key:#{opts.k8s[:k8s_configmap_key]}" \
      ": Sync performed"
    puts "post-sync status: #{tcm.insync?(desired_conf)}"
  end
end

def update_deployment_volume(opts)
  client = opts.k8s.to_api
  item = DeploymentVolumeItem.new(client,
                                  opts.k8s[:k8s_namespace],
                                  opts.k8s[:k8s_deployment],
                                  opts.k8s[:k8s_volume],
                                  opts.k8s[:k8s_configmap],
                                  opts.k8s[:k8s_configmap_key])

  desired = {
    key: opts.k8s[:k8s_configmap_key],
    path: "telegraf.d/#{opts.k8s[:k8s_configmap_key]}"
  }

  synced = item.insync?(desired)
  puts "k8s volume item insync: #{synced}"
  puts item.diff(desired) if !synced

  if item.sync(desired)
    puts "ns:#{opts.k8s[:k8s_namespace]}" \
      ":deployment:#{opts.k8s[:k8s_deployment]}" \
      ":volume:#{opts.k8s[:k8s_volume]}" \
      ": Sync performed"
    puts "post-sync status: #{item.insync?(desired)}"
  end
end

def update_config(opts, desired_conf)
  update_configmap(opts, desired_conf)
  update_deployment_volume(opts)
end

def run(opts)
  desired_conf = gen_config(opts)
  update_config(opts, desired_conf)
end

# Parse options from the environment and CLI.
#
# TODO: refactor options handling to reduce the ABC complexity of this method.
#
# rubocop:disable Metrics/AbcSize
def parse!(argv)
  # Set default values from the environment
  opts = Options.from_env(ENV)

  parser = OptionParser.new do |p|
    p.banner = "Usage: #{$PROGRAM_NAME} [options]"

    p.on("--help", "Display this help") do
      puts p
      exit 0
    end

    p.on("--debug", "Enable debug level logging") do
      opts.debug = true
    end

    p.on("--foreman-username=NAME", "The foreman username, default: env FOREMAN_USERNAME") do |name|
      opts.foreman[:foreman_username] = name
    end

    p.on("--foreman-password=PASSWORD", "The foreman password, default: env FOREMAN_PASSWORD") do |password|
      opts.foreman[:foreman_password] = password
    end

    p.on("--foreman-url=NAME", "The foreman base URL, default: env FOREMAN_URL") do |url|
      opts.foreman[:foreman_url] = url
    end

    p.on("--ssl-ca-file=FILE", "The Foreman CA certificate bundle, default: env SSL_CA_FILE") do |file|
      opts.foreman[:ssl_ca_file] = file
    end

    p.on("--k8s-credentials=CREDENTIALS", "The Kubernetes credentials source") do |value|
      opts.k8s[:k8s_credentials] = value
    end

    p.on("--k8s-namespace=NAMESPACE", "The Kubernetes namespace") do |value|
      opts.k8s[:k8s_namespace] = value
    end

    p.on("--k8s-configmap=CONFIGMAP", "The Kubernetes configmap") do |value|
      opts.k8s[:k8s_configmap] = value
    end

    p.on("--k8s-configmap-key=KEY", "The Kubernetes configmap key") do |value|
      opts.k8s[:k8s_configmap_key] = value
    end

    p.on("--k8s-deployment=DEPLOYMENT", "The Kubernetes deployment") do |value|
      opts.k8s[:k8s_deployment] = value
    end

    p.on("--k8s-volume=VOLUME", "The Kubernetes deployment volume") do |value|
      opts.k8s[:k8s_volume] = value
    end
  end

  # Populate values from the CLI
  parser.parse!(argv)

  if (errors = opts.validate!).any?
    abort "Missing configuration:\n#{errors.map { |e| "  #{e}" }.join("\n")}"
  end
  opts
end
# rubocop:enable Metrics/AbcSize

def main(argv)
  opts = parse!(argv)
  run(opts)
end

if File.basename($PROGRAM_NAME) == File.basename(__FILE__)
  main(ARGV)
end
